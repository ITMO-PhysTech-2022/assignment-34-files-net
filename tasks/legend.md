## Assignment 3-4 [Files & Network]

### Подготовка

1. Поставьте [`Python 3.11`](https://www.python.org/downloads/)
2. Поставьте библиотеки `decorator`, `requests` и **`pytest`**
    * `pip3 install decorator requests pytest` или
    * Настройки &rightarrow; `Project: assignment-...` &rightarrow; `Python Interpreter` &rightarrow;
      выбрать `Python 3.11` &rightarrow; нажать `+` над списком пакетов, установить
3. Установите папку `tasks` как `Sources Root`, папку `test` как `Test Sources Root`,
   и папку `resources` как `Resource Root`
    * нажать по папке правой кнопкой мыши &rightarrow; (внизу) `Mark Directory as` &rightarrow;
      соответствующий вариант

После того, как это будет сделано, папка `tasks` будет выделена синим, а `test` &ndash; зеленым. При этом никакие
импорты в коде не должны подсвечиваться красным.

---

### Краткое введение

Это задание &ndash; &laquo;консольный&raquo; текстовый редактор, в котором можно редактировать тестовые файлы с помощью
простых команд. Ваша задача &ndash; реализовать эти самые команды. Все остальное уже написано за вас.

Вам понадобится отредактировать три файла:

* [`main.py`](main.py) [задание 1]
* [`driver/files/commands.py`](driver/files/commands.py) [задание 2]
* [`driver/networks/commands.py`](driver/network/commands.py) [задание 3]

В каждом из этих трех файлов доступны специальные переменные `data`, `main` и `pool`.
Далее дано описание основных возможностей `data` и `main`, про `pool` будет написано ниже (в задании 2.5).

#### Данные в текстовом редакторе `data`

_Основные данные_:

* `data.lines` &ndash; массив строк
* `data.cursor` &ndash; позиция курсора, кортеж из двух элементов (номер строки, позиция в строке)
* `data.lines[i]` или просто `data[i]` &ndash; `i`-я строка в редакторе

_Вспомогательные данные_:

* `data.y` &ndash; номер строки с курсором (то же самое, что и `data.cursor[0]`)
* `data.x` &ndash; позиция курсора в строке (то же самое, что и `data.cursor[1]`)
* `data.line` &ndash; текущая строка (строка, на которой находится курсор)

Все эти объекты можно воспринимать как самостоятельные переменные. Количество строк можно получить как `len(data.lines)`
или, еще проще, `len(data)`.

#### Основной рабочий процесс `main`

* `main.report(message)` &ndash; вывести на экран сообщение `message`
* `main.report(message, error)` &ndash; вывести на экран сообщение `message` и статус ошибки `error`
* `main.execute(line)` &ndash; выполнить команду, заданную строкой `line`

### Задание 1

#### Задание 1.0

Основной исполняемый файл &ndash; [`main.py`](main.py). Запустите его. Если у вас не получилось его запустить
(вывелась ошибка) &ndash; поднимитесь в самый верх файла, который вы сейчас читаете, и выполните все пункты раздела
**Подготовка**.

Если у вас все еще не запускается,

1. проверьте, что у вас в проекте выбран именно `Python 3.11`
2. проверьте, что у вас код не подсвечивается красным
    * если `import что-то` подсвечивается красным, установите эти библиотеки
    * если что-то другое подсвечивается красным, напишите [`@doreshnikov`](https://t.me/doreshnikov)

После того, как ваш код запустился, вам в консоль должно вывестись слово `Ellipsis`. Напишите `exit` и нажмите `Enter`,
приложение должно завершиться.

#### Задание 1.1

Реализуйте поддержку задания конфигурации приложения в `json`-файле.
Рядом с исполняемым файлом уже лежит файл [`config.json`](config.json) &ndash; в нем заданы свойства, регулирующие
работу программы.

В файле [`main.py`](main.py) объявлены три переменные:

* `DISPLAY` &ndash; отображать ли содержимое редактора после каждой команды
* `DISPLAY_MARGIN` &ndash; сколько строк вокруг текущей отображать
* `PREFIX` &ndash; последовательность, отображаемая перед вводом команды

Сейчас им присвоено значение `...`. Считайте значения из файла [`config.json`](config.json) и присвойте этим переменным
соответствующие значения. (**Это не означает, что надо просто скопировать значения из файла с конфигом, надо его открыть
и прочитать из программы!**).

Теперь, если вы запустите `main.py`, у вас должен отобразиться `$` вместо `Ellipsis`.

### Задание 2

Откройте файл [`driver/files/commands.py`](driver/files/commands.py). В этом файле заданы описания команд, которые можно
использовать для редактирования файлов.

**Все команды, в которых нет комментария со словом `TODO`**, будут доступны для использования.

#### Задание 2.0

Удалите строчки с комментариями из команд `example` и `example_square`.
Запустите приложение. Введите команду `help`, вам должен вывестись список всех доступных команд, в котором в том числе
должны быть перечислены `example` и `example_square`.

Введите команду `example`. Вам должно вывестись сообщение, заданное в теле функции.

Введите команду `example_square`, передав ей через пробел в качестве аргумента какое-то число. Например,

```
$ example
 > Команда-пример, выводит это сообщение
$ example_square 77
 > 5929
```

**Как можно было заметить, если вы вернете какое-то значение из функции, задающей команду, оно будет напечатано при
вызове этой команды.**

Если все сработало правильно, можно двигаться дальше :)

#### Задание 2.1

В следующем блоке команд находятся `clear`, `discard`, `read` и `save`.

Первые две команды уже реализованы в качестве примера работы с переменной `data`. Например, команда `clear`:

* очищает данные в редакторе (оставляет одну пустую строку)
* выставляет курсор на нулевую строку на нулевую позицию

Реализуйте команды `read` и `save`. Чтение из файла и запись в файл должны производиться в кодировке `utf-8`.

1. Команда `read` должна
    * читать файл, находящийся по адресу `filename`
    * заполнять `data.lines` строками из него (без переводов строк в конце)
        * для этого можно использовать метод строки `.removesuffix('\n')`
    * выставлять курсор на позицию `(0, 0)`
2. Команда `save` должна
    * записывать все строки из `data.lines` в файл по адресу `filename`
    * **НЕ** изменять `data.lines` и `data.cursor`

Создайте папку `tmp` в папке [`resources`](../resources). Запустите приложение. Введите команды:

```
$ read config.json
 > Прочитано 7 строк
$ save ../resources/tmp/config.json
 > Сохранено 7 строк
```

Вывод команд `read` и `save` должен быть похож на приведенный выше. Откройте файл
[`config.json`](../resources/tmp/config.json) в папке [`resources/tmp`](../resources/tmp). Он должен совпадать с тем
конфигом, который лежит рядом с заданиями и кодом.

Если все ок, можно двигаться дальше :)

#### Задание 2.2

В следующем блоке находятся команды для вывода информации об открытом в редакторе файле: `total`, `cursor`, `linewidth`
и `show`. Первые три, опять же, уже реализованы.

Запустите приложение, введите команду `read config.json`, после чего по очереди введите команды `total`, `cursor` и
`linewidth 0` &ndash; вам выведется число строк и число символов в файле, позиция курсора и длина нулевой строки.

```
$ read config.json
 > Прочитано 7 строк
$ total
 > (7, 67)
$ cursor
 > (0, 0)
$ linewidth 0
 > 1
```

Реализуйте команду `show`, выводящую все строки с номерами от `from_line` до `to_line` включительно.

* в данной команде используйте `print` вместо `main.report` для вывода
* перед каждой строкой выведите ее номер, двоеточие и пробел
* номер строки должен занимать одинаковое по ширине место для всех строк
    * этого можно добиться форматной строкой, например `f'13: <4'` вернет `'  13'`, то есть дополнит пробелами в начале
      до четырех символов
* если в вывод попадает текущая строка (с номером `data.y`), после нее надо вывести пустую строку с указателем `^` на
  позицию курсора в строке

Пример вывода при курсоре на девятой строке на пятой позиции:

```
$ show 8 11
 8: Somebody once told me the world is gonna roll me
 9: I ain't the sharpest tool in the shed
         ^
10: She was looking kind of dumb with her finger and her thumb
11: In the shape of an "L" on her forehead
```

Протестируйте на каком-то большом файле (например, на этом же `legend.md`).

**Помните задание 1? Где вы настраивали чтение конфига. Поле `'display'` отвечает за то, чтобы после каждой 
команды, которая не имеет собственного возвращаемого значения, вызывать `show`.** Так что не пугайтесь, что вам теперь 
после каждого `read` или `move` или любого другого действия будут выводиться строки вокруг текущей. Если это мешает или 
отвлекает, просто замените `true` на `false` в [`config.json`](config.json).

#### Задание 2.3

В этом блоке вам предстоит реализовать функции для добавления текста в редактор. Здесь уже реализованы команды для
перемещения курсора (`move` перемещает на определенную позицию, `home` и `end` &ndash; в начало и конец текущей строки,
`down` и `up` &ndash; на строку вверх и на строку вниз).

От вас требуется написать реализацию команд `newline` и `type_inline`.

1. Команда `newline` должна соответствовать созданию перевода строки в том месте, где сейчас находится курсор
    * все строки до текущей остаются неизменными
    * все строки после текущей остаются неизменными
    * текущая строка разбивается на две: до и после курсора
    * курсор стоит на начале второй &laquo;половины&raquo; исходной текущей строки
2. Команда `type_inline` должна
    * добавлять строку `insertion` в текущую строку после позиции курсора
    * сдвигать курсор на окончание добавленной части

После того, как реализуете команду `type_inline`, автоматически станет доступна команда `type`, которая запрашивает
ввод на следующей строке, а не отдельным аргументом.

Например, для файла из строк `'Row zero'`, `'Row 1'` и `'Row dos'` (если в конфиге стоит `show: true` и `margin: 1`)

* сдвигаемся на первую строку

```
$ show 0 2
0: Row zero
   ^
1: Row 1
2: Row dos
$ move 1 2
0: Row zero
1: Row 1
     ^
2: Row dos
```

* печатаем `'lex'` и перевод строки с помощью `type_inline` и `newline`

```
$ type_inline lex 
0: Row zero
1: Rolexw 1
        ^
2: Row dos
$ newline
1: Rolex
2: w 1
   ^
3: Row dos
```

* перемещаемся на символ вперед и печатаем `'atch and more'` с помощью `type`

```
$ move 2 1
1: Rolex
2: w 1
    ^
3: Row dos
$ type
atch and more
1: Rolex
2: watch and more 1
                 ^
3: Row dos
```

**Большая подсказка: используйте срезы, они вам очень помогут!** Например, `data.lines[:data.y]` &ndash; все строки до
текущей, а `data.line[:data.x]` &ndash; символы текущей строки до курсора.

Протестируйте на каком-нибудь файле, убедитесь, что все работает, и можно идти дальше.

#### Задание 2.4.1

Ну раз реализовали добавление текста, то надо реализовать и удаление.
Реализуйте команду `backspace`, которая удаляет `count` символов влево от позиции курсора.

План действий для `backspace`:

* если в текущей строке до курсора меньше `count` символов, надо
    * удалить `data.x` символов (все начало строки)
    * удалить перевод строки между текущей и предыдущей (при этом склеив предыдущую строку и то, что осталось от
      текущей)
    * уменьшить оставшийся `count` на `data.x + 1`
    * поставить курсор в то место, где раньше был конец предыдущей строки
* иначе достаточно просто удалить `count` символов из текущей строки до курсора

Каждое действие само по себе простое, но их много, так что важно не запутаться. Напишите как получится, потом тестируйте
на каком-нибудь файле &ndash; если что-то будет не так, по выводу `show` будет видно, что именно.

#### Задание 2.4.2

Заодно еще можно реализовать поиск. Команда `find_inline` должна находить первое вхождение строки `text` в файл.
Достаточно пройтись по строкам в `data.lines` и в каждой сделать `.find(text)`. Функция должна возвращать кортеж из
номера строки и позиции начала вхождения `text` в нее.

Например,

* посмотрим на поиск слова `appearance` в следующем тексте:

```
$ show 0 1
0: first appearance
1: and second appearance
$ find_inline something
 > Not found
$ find_inline appearance
 > (0, 6)
```

* теперь удалим букву в первом слове `appearance` и сделаем поиск заново

```
$ move 0 7
$ backspace 1
$ show 0 1
0: first ppearance
         ^
1: and second appearance
$ find_inline appearance
 > (1, 11)
```

#### Задание 2.5

В этом блоке находятся сложные команды для создания продвинутых скриптов для редактирования файлов.
Уже написаны команды `macro` и `repeat`.

##### Небольшое отступление про `pool`

Вместе с `data` и `main` вы так же можете пользоваться переменной `pool`. Она хранит в себе очередь команд на
исполнение.

* `pool.next()` возвращает следующую команду (если вы посмотрите на последние строки в
  [`main.py`](main.py), то вся работа совершается как `while True: main.execute(pool.next())`)
    * если на очереди нет следующей команды, команда запрашивается с клавиатуры (это ровно то, что и происходило все это
      время &ndash; вы вводили команды с клавиатуры)
* `pool.put(commands)` добавляет команды `commands` **следующими** на исполнение, то есть эти добавленные команды будут
  вызваны сразу после текущей в том порядке, в котором лежат в массиве `commands`

Вам может понадобиться использовать `pool` в рамках заданий 2.5 и 2.*.

##### Возвращаемся к заданию

Команда `macro` позволяет запомнить некоторую последовательность команд под
определенным именем, чтобы потом ее переиспользовать или вызывать несколько раз. Команда `repeat` позволяет вызвать
определенный макрос заданное число раз.

Чтобы задать макрос, достаточно вызвать команду, указав имя создаваемого макроса, после чего вводить составляющие его
команды. Чтобы остановить ввод макроса, надо ввести команду `stop`.

Например:

* создаем макрос для перехода в начало строки, печати `'# '` (да, там есть пробел после решетки)
  и спуска на строку вниз

```
$ macro COMMENT_LINE_AND_GO_DOWN
    home
    type_inline # 
    down
    stop
$ show 0 2
0: from module import function
1: def f(x):
2:     print(x)
```

* вызываем этот макрос трижды

```
$ move 0 0
$ repeat COMMENT_LINE_AND_GO_DOWN 3
$ show 0 2
0: # from module import function
1: # def f(x):
2: #     print(x) 
```

Так вот, собственно, задание. Реализуйте возможность читать и добавлять в очередь на исполнение &laquo;скрипты&raquo;,
состоящие из команд. Команда `execute` должна принимать в качестве аргумента путь к файлу со скриптом, читать его и
добавлять в очередь `pool` все команды в нем.

Требования:

* в скрипте могут быть отступы, поэтому при чтении строк удаляйте все пробельные символы из начала (`.lstrip()`)
* в скрипте могут быть пустые строки, их стоит просто пропускать и не добавлять в очередь
* при чтении строк из файла скрипта с помощью `.readlines()` строки будут заканчиваться на перевод строки &ndash; его
  следует удалить с помощью метода строки `.removesuffix('\n')`

Пример использования (уже написан скрипт, добавляющий `'# '` в начало каждой строки в файле, он лежит в
[`resources/scripts/comment.s`](../resources/scripts/comment.s)):

```
$ read driver/utils.py
 > Прочитано 17 строк
$ show 0 3
0: from __future__ import annotations
1: from decorator import decorator
2: 
3: from tasks.core import data, main
$ execute ../resources/scripts/comment.s
$ show 0 3
0: # from __future__ import annotations
1: # from decorator import decorator
2: # 
3: # from tasks.core import data, main
```

### Задание 2.* (ультра-продвинутое, бонусное)

Уже реализованы за вас команды, позволяющие в скриптах создавать и использовать переменные:

1. Команда `use`
    * открывает блок команд, использующих переданные в `use` переменные
    * блок завершается командой `stop`
2. Команда `set_int`
    * принимает имя переменной и целочисленное значение
    * присваивает переменной соответствующее значение
3. Команда `set_str`
    * принимает имя переменной и строковое значение
    * присваивает переменной соответствующее значение
4. Команда `set_cmd`
    * принимает в качестве аргумента имя переменной
    * использует возвращаемое значение следующей команды и присваивает его данной переменной
4. Команда `set_eval`
    * принимает в качестве аргумента имя переменной
    * использует следующую команду как питоновское выражение, которое вычисляет и присваивает данной переменной
5. Команда `get`
    * принимает в качестве аргумента имя переменной
    * возвращает значение данной переменной
6. Команда `if_eval`
   * считывает следующую команду как питоновское выражение
   * считывает еще одну команду
   * выполняет ее только если значение текущего выражения истинно (`if value: ...`)

Пример использования:

* присваиваем переменной `LINES` результат выполнения команды `total` (то есть кортеж из числа строк и числа символов)

```
$ set_cmd LINES
    total
```

* присваиваем переменной `LINES` ее нулевой элемент (для использования значения переменной в командах ее надо обернуть
  в фигурные скобки)

```
$ set_eval LINES
    {LINES}[0]
```

* если количество строк больше 10, выходим:

```
$ use LINES
    if_eval
        {LINES} > 10
        exit
```

Задание:

0. Посмотрите на скрипты в папке [`resources/scripts`](../resources/scripts) и разберитесь в принципах их работы
1. Напишите скрипт, который заменяет все вхождения строки, записанной в переменную `BAN` на равное ее длине число
   звездочек (`'*'`). Сохраните этот скрипт в ту же папку со скриптами под именем `ban.s`
2. Напишите скрипт `process.s`, который
    * читает файл с именем, записанным в переменную `FILE`
    * удаляет все пробелы и переводы строк
    * записывает в файл с именем `'{FILE}.processed'`
        * в первой строке &ndash; то, что осталось
        * во второй строке &ndash; суммарное число удаленных пробелов и переводов строк

### Задание 3

Откройте файл [`driver/network/commands.py`](driver/network/commands.py). В этом файле заданы описания команд, которые
можно использовать для получения и отправки редактируемых файлов по сети.

**Все команды, в которых нет комментария со словом `TODO`**, будут доступны для использования.

#### Задание 3.1

Реализуйте команду `request`, которая принимает адрес в сети, отправляет в него `HTTP GET` запрос и записывает
полученный ответ в `data`. Курсор так же следует выставить в `(0, 0)`.

Для запроса в сеть используйте библиотеку `requests`. У возвращаемого ответа есть поле `.text`, которое следует разбить
по переводу строки (`'\n'`) и записать в `data.lines`.

Для проверки можете запустить следующие команды:

```
$ request https://api.github.com
$ show 0 3
0: {
1:   "current_user_url": "https://api.github.com/user",
2:   "current_user_authorizations_html_url": "https://github.com/settings/connections/applications{/client_id}",
3:   "authorizations_url": "https://api.github.com/authorizations",
```

Должен получиться такой же вывод, что и написан выше.

**P.S. Иногда `api.github.com` ведет себя странно и возвращает ответ без переводов строк.** Можете попробовать сделать
запрос несколько раз или попробовать другое API, например `https://jsonplaceholder.typicode.com/posts`. Также должно 
работать с любой html-страницей, можете даже сделать запрос на `https://vk.com` и получить в ответ html. 

#### Задание 3.2

Реализуйте команды `await_receive` и `send`, позволяющие двум версиям этого приложения обмениваться текстовыми данными
через сокеты.

1. Команда `await_receive` должна
    * принимать номер порта, на котором создавать сокет
    * создать сокет (`bind`, `listen`) и ожидать подключения (`accept`)
    * после чего принять все данные со входящего подключения и заполнить ими `data.lines`
2. Команда `send`
    * должна принять адрес и порт, на которые отправлять данные
    * создать подключение к сокету по данному адресу (`connect`)
    * после чего отправить на него все данные из `data.lines`

План:

* перед отправкой склейте все строки в одну через `'\n'` и добавьте нулевой байт в конец
* при получении принимайте данные до тех пор, пока не получите нулевой байт

Для тестирования работоспособности придется настроить возможность одновременного запуска двух приложений. Как это 
сделать, можно посмотреть [тут](https://t.me/c/1548400506/1868?thread=1817).

Запустите два инстанса приложения, после чего в первом введите команду

```
$ await_receive 60000
```

а во втором:

```
$ read main.py
$ send 127.0.0.1 60000
```

После ввода этих команд в оба приложения, обе команды должны успешно завершиться и вывести сообщения о количестве
полученных/отправленных строк. Если после этого ввести в первое приложение команду `show`, должно отобразиться
содержимое файла [`main.py`](main.py).

#### Задание 3.* (ультра-бонусное)

Напишите два скрипта, `send.s` и `receive.s`.

1. Первый скрипт, `send.s` должен
    * читать из переменной `PATH` путь к папке с файлами, и из переменной `COUNT` &ndash;
      количество файлов в папке
    * читать из переменной `ADDRESS` и переменной `PORT` адрес назначения
    * после чего по очереди читать и отправлять по адресу назначения файлы `'{PATH}/1'`, `'{PATH}/2'`,
      и так далее до `'{PATH}/{COUNT}'`
2. Аналогично, `receive.s` должен
    * читать путь из `PATH` и количество файлов из `COUNT`
    * читать порт из `PORT`
    * создавать сокет на данном порту и принимать ровно `COUNT` файлов, сохраняя их по аналогично устроенным путям

Протестируйте, создав в папке [`resources/tmp`](../resources/tmp) файлы с названиями от `1` до `10`, и вызвав эти
скрипты:
* в первом инстансе приложения
```
$ set_str PATH ../resources/
$ set_int COUNT 10
$ execute ../resources/scripts/receive.s
```
* и во втором
```
$ set_str PATH ../resources/tmp/
$ set_int COUNT 10
$ execute ../resources/scripts/send.s
```

Оба приложения должны завершить исполнение команд, а в папке [`resources`](../resources) должны появиться идентичные 
файлы от `1` до `10`. 